import grpc
from github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.generated_pb2 import Model as MDModel
from github.com.metaprov.modelaapi.services.model.v1.model_pb2_grpc import ModelServiceStub
from github.com.metaprov.modelaapi.services.model.v1.model_pb2 import \
    DeleteModelRequest, GetModelRequest, ListModelsRequest, \
    AbortModelRequest, CompileModelRequest, DeployModelRequest, DownloadModelRequest, \
    PauseModelRequest, GetModelProfileRequest, PublishModelRequest, ResumeModelRequest, TestModelRequest

from modela.Resource import Resource
from modela.ModelaException import ModelaException
from typing import List, Union

from modela.training.Report import Report
from modela.training.common import ModelPhase
from modela.training.models import ModelSpec, ModelStatus, ModelProfile


class Model(Resource):
    def __init__(self, item: MDModel = MDModel(), client=None, namespace="", name=""):
        """
        The Model resource is a machine learning model generated by the Modela data plane. Models are immutable and
        cannot be changed once created.

        :param client: The Model client repository, which can be obtained through an instance of Modela.
        :param namespace: The target namespace of the resource.
        :param name: The name of the resource.
        """
        super().__init__(item, client, namespace=namespace, name=name)

    @property
    def spec(self) -> ModelSpec:
        return ModelSpec().copy_from(self._object.spec)

    @property
    def status(self) -> ModelStatus:
        return ModelStatus().copy_from(self._object.status)

    def default(self):
        raise TypeError("Model {0} was not found; model resources cannot be created.".format(self.name))

    def submit(self):
        raise TypeError("Model resources cannot be created.")

    def update(self):
        raise TypeError("Model resources cannot be updated.")

    def profile(self) -> ModelProfile:
        if hasattr(self, "_client"):
            profile = self._client.profile(self.namespace, self.name)
        else:
            raise AttributeError("Object has no client repository")

        return ModelProfile().copy_from(profile)

    def abort(self):
        if hasattr(self, "_client"):
            self._client.abort(self.namespace, self.name)
        else:
            raise AttributeError("Object has no client repository")

    def pause(self):
        if hasattr(self, "_client"):
            self._client.pause(self.namespace, self.name)
        else:
            raise AttributeError("Object has no client repository")

    def resume(self):
        if hasattr(self, "_client"):
            self._client.resume(self.namespace, self.name)
        else:
            raise AttributeError("Object has no client repository")

    def compile(self, target, compiler):
        if hasattr(self, "_client"):
            self._client.compile(self.namespace, self.name, target, compiler)
        else:
            raise AttributeError("Object has no client repository")

    def publish(self):
        if hasattr(self, "_client"):
            self._client.publish(self.namespace, self.name)
        else:
            raise AttributeError("Object has no client repository")

    def test(self):
        if hasattr(self, "_client"):
            self._client.test(self.namespace, self.name)
        else:
            raise AttributeError("Object has no client repository")

    def download(self) -> bytes:
        if hasattr(self, "_client"):
            return self._client.download(self.namespace, self.name)
        else:
            raise AttributeError("Object has no client repository")

    def deploy(self, predictor: str, replicas: int = 0, traffic: int = 0, role: str = ""):
        if hasattr(self, "_client"):
            self._client.deploy(self.namespace, self.name, predictor, replicas, traffic, role)
        else:
            raise AttributeError("Object has no client repository")

    @property
    def report(self) -> Report:
        if hasattr(self, "_client"):
            if self._object.status.reportName != "":
                return self._client.modela.Report(namespace=self.namespace, name=self._object.status.reportName)
            else:
                print("Model {0} has no report. Call Model.test() to create one.")
        else:
            raise AttributeError("Object has no client repository")

    @property
    def phase(self) -> ModelPhase:
        return self.status.Phase



class ModelClient:
    def __init__(self, stub, modela):
        self.__stub: ModelServiceStub = stub
        self.modela = modela

    def create(self, model: Model) -> bool:
        raise TypeError("Modela currently does not support the creation of custom models.")
        # request = CreateModelRequest()
        # request.model.CopyFrom(model.raw_message)
        # try:
        #    response = self.__stub.CreateModel(request)
        #    return True
        # except grpc.RpcError as err:
        #    error = err

        # ModelaException.process_error(error)

    def update(self, model: Model) -> bool:
        raise TypeError("Model resources cannot be changed after creation.")
        # request = UpdateModelRequest()
        # request.model.CopyFrom(model.raw_message)
        # try:
        #    self.__stub.UpdateModel(request)
        #    return True
        # except grpc.RpcError as err:
        #    error = err

        # ModelaException.process_error(error)
        # return False

    def get(self, namespace: str, name: str) -> Union[Model, bool]:
        request = GetModelRequest()
        request.namespace = namespace
        request.name = name
        try:
            response = self.__stub.GetModel(request)
            return Model(response.model, self)
        except grpc.RpcError as err:
            error = err

        ModelaException.process_error(error)
        return False

    def delete(self, namespace: str, name: str) -> bool:
        request = DeleteModelRequest()
        request.namespace = namespace
        request.name = name
        try:
            response = self.__stub.DeleteModel(request)
            return True
        except grpc.RpcError as err:
            error = err

        ModelaException.process_error(error)
        return False

    def list(self, namespace: str, labels: dict[str, str] = None) -> Union[List[Model], bool]:
        request = ListModelsRequest()
        request.namespace = namespace
        if labels is not None:
            request.labels.update(labels)

        try:
            response = self.__stub.ListModels(request)
            return [Model(item, self) for item in response.models.items]
        except grpc.RpcError as err:
            error = err

        ModelaException.process_error(error)
        return False

    def abort(self, namespace: str, name: str) -> bool:
        request = AbortModelRequest()
        request.namespace = namespace
        request.name = name
        try:
            response = self.__stub.AbortModel(request)
            return True
        except grpc.RpcError as err:
            error = err

        ModelaException.process_error(error)
        return False

    def compile(self, namespace: str, name: str, target: str, compiler: str) -> bool:
        request = CompileModelRequest()
        request.namespace = namespace
        request.name = name
        request.target = target
        request.compiler = compiler
        try:
            response = self.__stub.CompileModel(request)
            return True
        except grpc.RpcError as err:
            error = err

        ModelaException.process_error(error)
        return False

    def deploy(self, namespace: str, name: str, predictor: str, replicas: int = 0,
               traffic: int = 0, role: str = "") -> bool:
        request = DeployModelRequest()
        request.namespace = namespace
        request.name = name
        try:
            response = self.__stub.DeployModel(request)
            return True
        except grpc.RpcError as err:
            error = err

        ModelaException.process_error(error)
        return False

    def download(self, namespace: str, name: str) -> bytes:
        request = DownloadModelRequest()
        request.namespace = namespace
        request.name = name
        try:
            response = self.__stub.DownloadModel(request)
            return response.raw
        except grpc.RpcError as err:
            error = err

        ModelaException.process_error(error)
        return False

    def pause(self, namespace: str, name: str) -> bool:
        request = PauseModelRequest()
        request.namespace = namespace
        request.name = name
        try:
            response = self.__stub.PauseModel(request)
            return True
        except grpc.RpcError as err:
            error = err

        ModelaException.process_error(error)
        return False

    def resume(self, namespace: str, name: str) -> bool:
        request = ResumeModelRequest()
        request.namespace = namespace
        request.name = name
        try:
            response = self.__stub.ResumeModel(request)
            return True
        except grpc.RpcError as err:
            error = err

        ModelaException.process_error(error)
        return False

    def test(self, namespace: str, name: str) -> bool:
        request = TestModelRequest()
        request.namespace = namespace
        request.name = name
        try:
            response = self.__stub.TestModel(request)
            return True
        except grpc.RpcError as err:
            error = err

        ModelaException.process_error(error)
        return False

    def profile(self, namespace: str, name: str) -> bool:
        request = GetModelProfileRequest()
        request.namespace = namespace
        request.name = name
        try:
            response = self.__stub.GetModelProfile(request)
            return response.profile
        except grpc.RpcError as err:
            error = err

        ModelaException.process_error(error)
        return False

    def publish(self, namespace: str, name: str) -> bool:
        request = PublishModelRequest()
        request.namespace = namespace
        request.name = name
        try:
            response = self.__stub.PublishModel(request)
            return True
        except grpc.RpcError as err:
            error = err

        ModelaException.process_error(error)
        return False


